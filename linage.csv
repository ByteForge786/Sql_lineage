SQL,Lineage
"CREATE VIEW customer_summary AS SELECT c.customer_id, c.first_name, c.last_name, c.email, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS total_spent, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, (SELECT GROUP_CONCAT(p.product_name SEPARATOR ', ') FROM order_details od JOIN products p ON od.product_id = p.product_id WHERE od.order_id IN (SELECT order_id FROM orders WHERE customer_id = c.customer_id) GROUP BY od.order_id ORDER BY o.order_date DESC LIMIT 1) AS last_order_products FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.first_name, c.last_name, c.email;","customers.customer_id -> customer_summary; customers.first_name -> customer_summary; customers.last_name -> customer_summary; customers.email -> customer_summary; orders.order_id -> customer_summary; orders.total_amount -> customer_summary; orders.order_date -> customer_summary; order_details.order_id -> customer_summary; order_details.product_id -> customer_summary; products.product_id -> customer_summary; products.product_name -> customer_summary"
"CREATE MATERIALIZED VIEW product_sales_summary AS SELECT p.product_id, p.product_name, c.category_name, SUM(od.quantity) AS total_quantity_sold, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_revenue, COUNT(DISTINCT o.customer_id) AS unique_customers FROM products p JOIN categories c ON p.category_id = c.category_id JOIN order_details od ON p.product_id = od.product_id JOIN orders o ON od.order_id = o.order_id WHERE o.order_date >= DATE_TRUNC('year', CURRENT_DATE) GROUP BY p.product_id, p.product_name, c.category_name;","products.product_id -> product_sales_summary; products.product_name -> product_sales_summary; products.category_id -> product_sales_summary; categories.category_id -> product_sales_summary; categories.category_name -> product_sales_summary; order_details.product_id -> product_sales_summary; order_details.quantity -> product_sales_summary; order_details.unit_price -> product_sales_summary; order_details.discount -> product_sales_summary; order_details.order_id -> product_sales_summary; orders.order_id -> product_sales_summary; orders.customer_id -> product_sales_summary; orders.order_date -> product_sales_summary"
"CREATE PROCEDURE update_product_ratings() BEGIN UPDATE products p SET p.average_rating = (SELECT AVG(rating) FROM product_reviews pr WHERE pr.product_id = p.product_id), p.review_count = (SELECT COUNT(*) FROM product_reviews pr WHERE pr.product_id = p.product_id), p.last_review_date = (SELECT MAX(review_date) FROM product_reviews pr WHERE pr.product_id = p.product_id); END;","products.product_id -> result; products.average_rating -> result; products.review_count -> result; products.last_review_date -> result; product_reviews.product_id -> result; product_reviews.rating -> result; product_reviews.review_date -> result"
"CREATE TRIGGER after_order_insert AFTER INSERT ON orders FOR EACH ROW BEGIN INSERT INTO order_history (order_id, customer_id, order_date, total_amount, status, created_at) VALUES (NEW.order_id, NEW.customer_id, NEW.order_date, NEW.total_amount, 'Placed', CURRENT_TIMESTAMP); UPDATE customers SET last_order_date = NEW.order_date, total_orders = total_orders + 1, total_spent = total_spent + NEW.total_amount WHERE customer_id = NEW.customer_id; END;","orders.order_id -> order_history; orders.customer_id -> order_history; orders.order_date -> order_history; orders.total_amount -> order_history; customers.customer_id -> result; customers.last_order_date -> result; customers.total_orders -> result; customers.total_spent -> result"
"CREATE INDEX idx_product_search ON products USING GIN (to_tsvector('english', product_name || ' ' || description));","products.product_name -> idx_product_search; products.description -> idx_product_search"
"CREATE FUNCTION get_product_revenue(p_product_id INT, start_date DATE, end_date DATE) RETURNS DECIMAL(10,2) AS $$ DECLARE total_revenue DECIMAL(10,2); BEGIN SELECT COALESCE(SUM(od.quantity * od.unit_price * (1 - od.discount)), 0) INTO total_revenue FROM order_details od JOIN orders o ON od.order_id = o.order_id WHERE od.product_id = p_product_id AND o.order_date BETWEEN start_date AND end_date; RETURN total_revenue; END; $$ LANGUAGE plpgsql;","order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result; order_details.product_id -> result; order_details.order_id -> result; orders.order_id -> result; orders.order_date -> result"
"MERGE INTO inventory_summary AS target USING (SELECT product_id, SUM(quantity) AS total_quantity FROM (SELECT product_id, quantity_in_stock AS quantity FROM products UNION ALL SELECT product_id, quantity FROM purchase_order_details WHERE purchase_order_id IN (SELECT purchase_order_id FROM purchase_orders WHERE status = 'Pending')) AS inventory_sources GROUP BY product_id) AS source ON (target.product_id = source.product_id) WHEN MATCHED THEN UPDATE SET total_quantity = source.total_quantity, last_updated = CURRENT_TIMESTAMP WHEN NOT MATCHED THEN INSERT (product_id, total_quantity, last_updated) VALUES (source.product_id, source.total_quantity, CURRENT_TIMESTAMP);","products.product_id -> inventory_summary; products.quantity_in_stock -> inventory_summary; purchase_order_details.product_id -> inventory_summary; purchase_order_details.quantity -> inventory_summary; purchase_order_details.purchase_order_id -> inventory_summary; purchase_orders.purchase_order_id -> inventory_summary; purchase_orders.status -> inventory_summary"
"WITH RECURSIVE employee_hierarchy(employee_id, manager_id, full_name, level) AS (SELECT employee_id, manager_id, CONCAT(first_name, ' ', last_name), 0 FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, CONCAT(e.first_name, ' ', e.last_name), eh.level + 1 FROM employees e JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id) SELECT eh.employee_id, eh.full_name, eh.level, d.department_name, COALESCE(manager.full_name, 'Top Level') AS manager_name, e.salary, e.hire_date FROM employee_hierarchy eh JOIN employees e ON eh.employee_id = e.employee_id JOIN departments d ON e.department_id = d.department_id LEFT JOIN employee_hierarchy manager ON eh.manager_id = manager.employee_id ORDER BY eh.level, eh.full_name;","employees.employee_id -> result; employees.manager_id -> employee_hierarchy; employees.first_name -> result; employees.last_name -> result; employees.department_id -> result; employees.salary -> result; employees.hire_date -> result; departments.department_id -> result; departments.department_name -> result"
"CREATE TYPE order_status AS ENUM ('Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled');","order_status -> result"
"CREATE TABLE audit_log (id SERIAL PRIMARY KEY, table_name VARCHAR(50), record_id INTEGER, action VARCHAR(10), changed_fields JSONB, changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, changed_by VARCHAR(50));","audit_log.id -> result; audit_log.table_name -> result; audit_log.record_id -> result; audit_log.action -> result; audit_log.changed_fields -> result; audit_log.changed_at -> result; audit_log.changed_by -> result"
"CREATE FUNCTION audit_trigger_func() RETURNS TRIGGER AS $$ DECLARE changed_fields JSONB; BEGIN IF TG_OP = 'INSERT' THEN changed_fields = to_jsonb(NEW); INSERT INTO audit_log (table_name, record_id, action, changed_fields, changed_by) VALUES (TG_TABLE_NAME, NEW.id, 'INSERT', changed_fields, current_user); ELSIF TG_OP = 'UPDATE' THEN changed_fields = jsonb_strip_nulls(to_jsonb(NEW) - to_jsonb(OLD)); IF changed_fields != '{}' THEN INSERT INTO audit_log (table_name, record_id, action, changed_fields, changed_by) VALUES (TG_TABLE_NAME, NEW.id, 'UPDATE', changed_fields, current_user); END IF; ELSIF TG_OP = 'DELETE' THEN changed_fields = to_jsonb(OLD); INSERT INTO audit_log (table_name, record_id, action, changed_fields, changed_by) VALUES (TG_TABLE_NAME, OLD.id, 'DELETE', changed_fields, current_user); END IF; RETURN NULL; END; $$ LANGUAGE plpgsql;","audit_log.table_name -> result; audit_log.record_id -> result; audit_log.action -> result; audit_log.changed_fields -> result; audit_log.changed_by -> result"
"CREATE TRIGGER products_audit_trigger AFTER INSERT OR UPDATE OR DELETE ON products FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();","products.id -> audit_log"
"CREATE EXTENSION IF NOT EXISTS postgis; CREATE TABLE store_locations (id SERIAL PRIMARY KEY, store_name VARCHAR(100), location GEOGRAPHY(POINT, 4326));","store_locations.id -> result; store_locations.store_name -> result; store_locations.location -> result"
"CREATE MATERIALIZED VIEW monthly_sales_summary AS SELECT DATE_TRUNC('month', o.order_date) AS month, p.category_id, c.category_name, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_sales, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT o.customer_id) AS customer_count FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id GROUP BY DATE_TRUNC('month', o.order_date), p.category_id, c.category_name; CREATE UNIQUE INDEX idx_monthly_sales_summary ON monthly_sales_summary (month, category_id);","orders.order_date -> monthly_sales_summary; orders.order_id -> monthly_sales_summary; orders.customer_id -> monthly_sales_summary; order_details.order_id -> monthly_sales_summary; order_details.quantity -> monthly_sales_summary; order_details.unit_price -> monthly_sales_summary; order_details.discount -> monthly_sales_summary; order_details.product_id -> monthly_sales_summary; products.product_id -> monthly_sales_summary; products.category_id -> monthly_sales_summary; categories.category_id -> monthly_sales_summary; categories.category_name -> monthly_sales_summary"
"CREATE FUNCTION calculate_distance(lat1 FLOAT, lon1 FLOAT, lat2 FLOAT, lon2 FLOAT) RETURNS FLOAT AS $$ DECLARE R INT = 6371; -- Radius of the earth in km lat1_rad FLOAT = radians(lat1); lat2_rad FLOAT = radians(lat2); lat_diff_rad FLOAT = radians(lat2-lat1); lon_diff_rad FLOAT = radians(lon2-lon1); a FLOAT = sin(lat_diff_rad/2) * sin(lat_diff_rad/2) + cos(lat1_rad) * cos(lat2_rad) * sin(lon_diff_rad/2) * sin(lon_diff_rad/2); c FLOAT = 2 * atan2(sqrt(a), sqrt(1-a)); d FLOAT = R * c; BEGIN RETURN d; END; $$ LANGUAGE plpgsql;",""
"CREATE TABLE product_variations (id SERIAL PRIMARY KEY, product_id INT REFERENCES products(id), sku VARCHAR(50) UNIQUE, color VARCHAR(50), size VARCHAR(20), weight DECIMAL(8,2), price DECIMAL(10,2), stock_quantity INT, UNIQUE (product_id, color, size));","product_variations.id -> result; product_variations.product_id -> result; product_variations.sku -> result; product_variations.color -> result; product_variations.size -> result; product_variations.weight -> result; product_variations.price -> result; product_variations.stock_quantity -> result; products.id -> product_variations"
"CREATE PROCEDURE generate_sales_report(start_date DATE, end_date DATE) LANGUAGE plpgsql AS $$ DECLARE report_data JSONB; BEGIN WITH sales_summary AS (SELECT p.category_id, c.category_name, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_sales, COUNT(DISTINCT o.order_id) AS order_count FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id WHERE o.order_date BETWEEN start_date AND end_date GROUP BY p.category_id, c.category_name), top_products AS (SELECT p.product_id, p.product_name, SUM(od.quantity) AS total_quantity, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_revenue FROM order_details od JOIN orders o ON od.order_id = o.order_id JOIN products p ON od.product_id = p.product_id WHERE o.order_date BETWEEN start_date AND end_date GROUP BY p.product_id, p.product_name ORDER BY total_revenue DESC LIMIT 10) SELECT jsonb_build_object('start_date', start_date, 'end_date', end_date, 'total_sales', (SELECT SUM(total_sales) FROM sales_summary), 'total_orders', (SELECT SUM(order_count) FROM sales_summary), 'sales_by_category', (SELECT jsonb_agg(jsonb_build_object('category_name', category_name, 'total_sales', total_sales, 'order_count', order_count)) FROM sales_summary), 'top_products', (SELECT jsonb_agg(jsonb_build_object('product_name', product_name, 'total_quantity', total_quantity, 'total_revenue', total_revenue)) FROM top_products)) INTO report_data; INSERT INTO sales_reports (report_date, start_date, end_date, report_data) VALUES (CURRENT_DATE, start_date, end_date, report_data); END; $$;","orders.order_id -> sales_reports; orders.order_date -> sales_reports; order_details.order_id -> sales_reports; order_details.product_id -> sales_reports; order_details.quantity -> sales_reports; order_details.unit_price -> sales_reports; order_details.discount -> sales_reports; products.product_id -> sales_reports; products.product_name -> sales_reports; products.category_id -> sales_reports; categories.category_id -> sales_reports; categories.category_name -> sales_reports; sales_reports.report_date -> result; sales_reports.start_date -> result; sales_reports.end_date -> result; sales_reports.report_data -> result"
"WITH RECURSIVE employee_hierarchy AS (SELECT employee_id, manager_id, first_name, last_name, salary, hire_date, 1 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, e.first_name, e.last_name, e.salary, e.hire_date, eh.level + 1 FROM employees e JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id), dept_stats AS (SELECT department_id, AVG(salary) AS avg_salary, COUNT(*) AS emp_count FROM employees GROUP BY department_id), emp_performance AS (SELECT employee_id, AVG(rating) AS avg_rating FROM performance_reviews WHERE review_date >= DATE_SUB(CURRENT_DATE, INTERVAL 2 YEAR) GROUP BY employee_id) SELECT eh.employee_id, eh.first_name, eh.last_name, eh.level, d.department_name, eh.salary, ds.avg_salary, (eh.salary - ds.avg_salary) AS salary_diff, eh.hire_date, DATEDIFF(CURRENT_DATE, eh.hire_date) / 365 AS years_employed, ep.avg_rating, (SELECT COUNT(*) FROM employee_hierarchy eh2 WHERE eh2.manager_id = eh.employee_id) AS direct_reports FROM employee_hierarchy eh JOIN employees e ON eh.employee_id = e.employee_id JOIN departments d ON e.department_id = d.department_id JOIN dept_stats ds ON d.department_id = ds.department_id LEFT JOIN emp_performance ep ON eh.employee_id = ep.employee_id ORDER BY eh.level, salary_diff DESC;","employees.employee_id -> result; employees.manager_id -> employee_hierarchy; employees.first_name -> result; employees.last_name -> result; employees.salary -> result; employees.hire_date -> result; employees.department_id -> result; departments.department_name -> result; departments.department_id -> result; performance_reviews.employee_id -> emp_performance; performance_reviews.rating -> emp_performance; performance_reviews.review_date -> emp_performance"
"CREATE PROCEDURE analyze_sales_trends() BEGIN DECLARE start_date DATE; DECLARE end_date DATE; SET start_date = DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR); SET end_date = CURRENT_DATE; WITH RECURSIVE date_series AS (SELECT start_date AS date UNION ALL SELECT date + INTERVAL 1 DAY FROM date_series WHERE date < end_date), daily_sales AS (SELECT DATE(o.order_date) AS sale_date, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS daily_revenue FROM orders o JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN start_date AND end_date GROUP BY DATE(o.order_date)), sales_stats AS (SELECT sale_date, daily_revenue, AVG(daily_revenue) OVER (ORDER BY sale_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_7day, AVG(daily_revenue) OVER (ORDER BY sale_date ROWS BETWEEN 29 PRECEDING AND CURRENT ROW) AS moving_avg_30day FROM daily_sales), seasonal_index AS (SELECT EXTRACT(MONTH FROM sale_date) AS month, AVG(daily_revenue) AS avg_monthly_revenue FROM daily_sales GROUP BY EXTRACT(MONTH FROM sale_date)), overall_avg AS (SELECT AVG(daily_revenue) AS avg_daily_revenue FROM daily_sales) SELECT ds.date, COALESCE(ss.daily_revenue, 0) AS daily_revenue, ss.moving_avg_7day, ss.moving_avg_30day, si.avg_monthly_revenue, oa.avg_daily_revenue, COALESCE(ss.daily_revenue, 0) - oa.avg_daily_revenue AS revenue_diff, (COALESCE(ss.daily_revenue, 0) - oa.avg_daily_revenue) / oa.avg_daily_revenue * 100 AS percent_diff, COALESCE(ss.daily_revenue, 0) / NULLIF(si.avg_monthly_revenue, 0) AS seasonal_factor FROM date_series ds LEFT JOIN sales_stats ss ON ds.date = ss.sale_date LEFT JOIN seasonal_index si ON EXTRACT(MONTH FROM ds.date) = si.month CROSS JOIN overall_avg oa ORDER BY ds.date; END;","orders.order_id -> result; orders.order_date -> result; order_details.order_id -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result"
"WITH customer_rfm AS (SELECT customer_id, MAX(order_date) AS last_order_date, COUNT(*) AS frequency, SUM(total_amount) AS monetary FROM orders GROUP BY customer_id), rfm_scores AS (SELECT customer_id, NTILE(5) OVER (ORDER BY last_order_date DESC) AS recency_score, NTILE(5) OVER (ORDER BY frequency) AS frequency_score, NTILE(5) OVER (ORDER BY monetary) AS monetary_score FROM customer_rfm), rfm_segments AS (SELECT customer_id, recency_score, frequency_score, monetary_score, CONCAT(recency_score, frequency_score, monetary_score) AS rfm_score, CASE WHEN (recency_score + frequency_score + monetary_score) >= 13 THEN 'Best Customers' WHEN (recency_score + frequency_score + monetary_score) >= 10 THEN 'Loyal Customers' WHEN (recency_score + frequency_score + monetary_score) >= 7 THEN 'Potential Churners' WHEN (recency_score + frequency_score + monetary_score) >= 5 THEN 'Lost Customers' ELSE 'Lost Cheap Customers' END AS customer_segment FROM rfm_scores) SELECT c.customer_id, c.first_name, c.last_name, c.email, rs.recency_score, rs.frequency_score, rs.monetary_score, rs.rfm_score, rs.customer_segment, cr.last_order_date, cr.frequency, cr.monetary, (SELECT JSON_ARRAYAGG(JSON_OBJECT('product_name', p.product_name, 'quantity', od.quantity)) FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id WHERE o.customer_id = c.customer_id ORDER BY o.order_date DESC LIMIT 5) AS last_5_products FROM customers c JOIN rfm_segments rs ON c.customer_id = rs.customer_id JOIN customer_rfm cr ON c.customer_id = cr.customer_id ORDER BY rs.rfm_score DESC;","customers.customer_id -> result; customers.first_name -> result; customers.last_name -> result; customers.email -> result; orders.customer_id -> result; orders.order_id -> result; orders.order_date -> result; orders.total_amount -> result; order_details.order_id -> result; order_details.product_id -> result; order_details.quantity -> result; products.product_id -> result; products.product_name -> result"
"CREATE FUNCTION calculate_product_profitability(product_id INT, start_date DATE, end_date DATE) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN DECLARE total_revenue DECIMAL(10,2); DECLARE total_cost DECIMAL(10,2); DECLARE total_quantity INT; DECLARE avg_unit_cost DECIMAL(10,2); DECLARE profit DECIMAL(10,2); SELECT COALESCE(SUM(od.quantity * od.unit_price * (1 - od.discount)), 0) INTO total_revenue FROM order_details od JOIN orders o ON od.order_id = o.order_id WHERE od.product_id = product_id AND o.order_date BETWEEN start_date AND end_date; SELECT COALESCE(AVG(unit_cost), 0) INTO avg_unit_cost FROM product_costs WHERE product_id = product_id AND effective_date <= end_date ORDER BY effective_date DESC LIMIT 1; SELECT COALESCE(SUM(quantity), 0) INTO total_quantity FROM order_details od JOIN orders o ON od.order_id = o.order_id WHERE od.product_id = product_id AND o.order_date BETWEEN start_date AND end_date; SET total_cost = avg_unit_cost * total_quantity; SET profit = total_revenue - total_cost; RETURN profit; END;","order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result; order_details.product_id -> result; order_details.order_id -> result; orders.order_id -> result; orders.order_date -> result; product_costs.product_id -> result; product_costs.unit_cost -> result; product_costs.effective_date -> result"
"WITH RECURSIVE category_tree AS (SELECT category_id, parent_category_id, category_name, 0 AS level, CAST(category_name AS CHAR(1000)) AS path FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.parent_category_id, c.category_name, ct.level + 1, CONCAT(ct.path, ' > ', c.category_name) FROM categories c JOIN category_tree ct ON c.parent_category_id = ct.category_id), category_sales AS (SELECT p.category_id, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_sales FROM order_details od JOIN products p ON od.product_id = p.product_id JOIN orders o ON od.order_id = o.order_id WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY p.category_id), category_stats AS (SELECT ct.category_id, ct.category_name, ct.level, ct.path, COALESCE(cs.total_sales, 0) AS total_sales, COUNT(p.product_id) AS product_count FROM category_tree ct LEFT JOIN category_sales cs ON ct.category_id = cs.category_id LEFT JOIN products p ON ct.category_id = p.category_id GROUP BY ct.category_id, ct.category_name, ct.level, ct.path, cs.total_sales) SELECT cs.*, (SELECT SUM(total_sales) FROM category_stats WHERE path LIKE CONCAT(cs.path, '%')) AS subtree_sales, (SELECT SUM(product_count) FROM category_stats WHERE path LIKE CONCAT(cs.path, '%')) AS subtree_product_count FROM category_stats cs ORDER BY cs.path;","categories.category_id -> result; categories.parent_category_id -> category_tree; categories.category_name -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result; order_details.product_id -> result; order_details.order_id -> result; products.product_id -> result; products.category_id -> result; orders.order_id -> result; orders.order_date -> result"
"CREATE PROCEDURE generate_inventory_report() BEGIN DECLARE report_date DATE; SET report_date = CURRENT_DATE; WITH inventory_snapshot AS (SELECT p.product_id, p.product_name, p.category_id, c.category_name, p.unit_price, p.quantity_in_stock, p.reorder_level, p.discontinued, COALESCE(po.pending_order_quantity, 0) AS pending_order_quantity FROM products p JOIN categories c ON p.category_id = c.category_id LEFT JOIN (SELECT product_id, SUM(quantity) AS pending_order_quantity FROM purchase_order_details pod JOIN purchase_orders po ON pod.purchase_order_id = po.purchase_order_id WHERE po.status = 'Pending' GROUP BY product_id) po ON p.product_id = po.product_id), sales_velocity AS (SELECT product_id, AVG(daily_sales) AS avg_daily_sales, STDDEV(daily_sales) AS stddev_daily_sales FROM (SELECT od.product_id, DATE(o.order_date) AS sale_date, SUM(od.quantity) AS daily_sales FROM order_details od JOIN orders o ON od.order_id = o.order_id WHERE o.order_date >= DATE_SUB(report_date, INTERVAL 90 DAY) GROUP BY od.product_id, DATE(o.order_date)) daily_sales GROUP BY product_id), inventory_analysis AS (SELECT is.*, sv.avg_daily_sales, sv.stddev_daily_sales, is.quantity_in_stock / NULLIF(sv.avg_daily_sales, 0) AS days_of_inventory, GREATEST(is.reorder_level, sv.avg_daily_sales * 7 + 2 * sv.stddev_daily_sales) AS suggested_reorder_level, CASE WHEN is.quantity_in_stock <= is.reorder_level THEN 'Reorder' WHEN is.quantity_in_stock <= is.reorder_level * 1.5 THEN 'Low Stock' WHEN is.quantity_in_stock >= sv.avg_daily_sales * 60 THEN 'Overstocked' ELSE 'OK' END AS stock_status FROM inventory_snapshot is LEFT JOIN sales_velocity sv ON is.product_id = sv.product_id) SELECT * FROM inventory_analysis ORDER BY category_name, product_name; END;","products.product_id -> result; products.product_name -> result; products.category_id -> result; products.unit_price -> result; products.quantity_in_stock -> result; products.reorder_level -> result; products.discontinued -> result; categories.category_id -> result; categories.category_name -> result; purchase_order_details.product_id -> result; purchase_order_details.quantity -> result; purchase_order_details.purchase_order_id -> result; purchase_orders.purchase_order_id -> result; purchase_orders.status -> result; order_details.product_id -> result; order_details.quantity -> result; order_details.order_id -> result; orders.order_id -> result; orders.order_date -> result"
"WITH RECURSIVE org_hierarchy AS (SELECT employee_id, manager_id, first_name, last_name, job_title, 1 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, e.first_name, e.last_name, e.job_title, oh.level + 1 FROM employees e JOIN org_hierarchy oh ON e.manager_id = oh.employee_id), emp_performance AS (SELECT employee_id, AVG(performance_score) AS avg_performance, COUNT(*) AS review_count FROM performance_reviews WHERE review_date >= DATE_SUB(CURRENT_DATE, INTERVAL 2 YEAR) GROUP BY employee_id), emp_projects AS (SELECT ep.employee_id, COUNT(DISTINCT p.project_id) AS project_count, AVG(p.project_score) AS avg_project_score FROM employee_projects ep JOIN projects p ON ep.project_id = p.project_id WHERE p.end_date >= DATE_SUB(CURRENT_DATE, INTERVAL 2 YEAR) OR p.end_date IS NULL GROUP BY ep.employee_id) SELECT oh.employee_id, oh.first_name, oh.last_name, oh.job_title, oh.level, COALESCE(ep.avg_performance, 0) AS avg_performance, COALESCE(ep.review_count, 0) AS review_count, COALESCE(epr.project_count, 0) AS project_count, COALESCE(epr.avg_project_score, 0) AS avg_project_score, (SELECT COUNT(*) FROM org_hierarchy oh2 WHERE oh2.manager_id = oh.employee_id) AS direct_reports FROM org_hierarchy oh LEFT JOIN emp_performance ep ON oh.employee_id = ep.employee_id LEFT JOIN emp_projects epr ON oh.employee_id = epr.employee_id ORDER BY oh.level, avg_performance DESC, avg_project_score DESC;","employees.employee_id -> result; employees.manager_id -> org_hierarchy; employees.first_name -> result; employees.last_name -> result; employees.job_title -> result; performance_reviews.employee_id -> emp_performance; performance_reviews.performance_score -> emp_performance; performance_reviews.review_date -> emp_performance; employee_projects.employee_id -> emp_projects; employee_projects.project_id -> emp_projects; projects.project_id -> emp_projects; projects.project_score -> emp_projects; projects.end_date -> emp_projects"
"WITH customer_activity AS (SELECT customer_id, COUNT(*) AS total_orders, SUM(total_amount) AS total_spent, MAX(order_date) AS last_order_date, MIN(order_date) AS first_order_date FROM orders GROUP BY customer_id), customer_segments AS (SELECT ca.*, CASE WHEN total_orders >= 10 AND total_spent >= 5000 THEN 'VIP' WHEN total_orders >= 5 AND total_spent >= 2000 THEN 'Regular' WHEN total_orders >= 2 AND total_spent >= 500 THEN 'Occasional' ELSE 'New' END AS segment, NTILE(5) OVER (ORDER BY total_spent DESC) AS spending_quintile, DATEDIFF(CURRENT_DATE, last_order_date) AS days_since_last_order FROM customer_activity), product_preferences AS (SELECT o.customer_id, p.category_id, c.category_name, COUNT(*) AS purchase_count, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS category_spent FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id GROUP BY o.customer_id, p.category_id, c.category_name) SELECT cs.customer_id, c.first_name, c.last_name, c.email, cs.total_orders, cs.total_spent, cs.last_order_date, cs.first_order_date, cs.segment, cs.spending_quintile, cs.days_since_last_order, pp.category_name AS top_category, pp.purchase_count AS top_category_purchases, pp.category_spent AS top_category_spent, (SELECT GROUP_CONCAT(DISTINCT p.product_name SEPARATOR ', ') FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id WHERE o.customer_id = cs.customer_id ORDER BY od.quantity DESC LIMIT 3) AS top_3_products FROM customer_segments cs JOIN customers c ON cs.customer_id = c.customer_id LEFT JOIN (SELECT customer_id, category_name, purchase_count, category_spent, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY category_spent DESC) AS category_rank FROM product_preferences) pp ON cs.customer_id = pp.customer_id AND pp.category_rank = 1 ORDER BY cs.spending_quintile, cs.total_spent DESC;","orders.customer_id -> result; orders.order_id -> result; orders.total_amount -> result; orders.order_date -> result; customers.customer_id -> result; customers.first_name -> result; customers.last_name -> result; customers.email -> result; products.product_id -> result; products.category_id -> result; products.product_name -> result; categories.category_id -> result; categories.category_name -> result; order_details.order_id -> result; order_details.product_id -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result"
"CREATE PROCEDURE update_inventory_and_reorder() BEGIN DECLARE done INT DEFAULT FALSE; DECLARE p_id INT; DECLARE p_name VARCHAR(255); DECLARE p_quantity INT; DECLARE p_reorder_level INT; DECLARE p_reorder_quantity INT; DECLARE supplier_id INT; DECLARE cur CURSOR FOR SELECT product_id, product_name, quantity_in_stock, reorder_level, reorder_quantity, preferred_supplier_id FROM products WHERE quantity_in_stock <= reorder_level; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; START TRANSACTION; OPEN cur; read_loop: LOOP FETCH cur INTO p_id, p_name, p_quantity, p_reorder_level, p_reorder_quantity, supplier_id; IF done THEN LEAVE read_loop; END IF; INSERT INTO purchase_orders (supplier_id, order_date, status) VALUES (supplier_id, CURRENT_DATE, 'Pending'); SET @last_po_id = LAST_INSERT_ID(); INSERT INTO purchase_order_details (purchase_order_id, product_id, quantity, unit_price) SELECT @last_po_id, p_id, p_reorder_quantity, unit_price FROM supplier_products WHERE supplier_id = supplier_id AND product_id = p_id; UPDATE products SET quantity_in_stock = quantity_in_stock + p_reorder_quantity, last_reorder_date = CURRENT_DATE WHERE product_id = p_id; INSERT INTO inventory_logs (product_id, change_type, quantity_change, change_date) VALUES (p_id, 'Reorder', p_reorder_quantity, CURRENT_DATE); END LOOP; CLOSE cur; COMMIT; END;","products.product_id -> purchase_order_details; products.product_name -> result; products.quantity_in_stock -> result; products.reorder_level -> result; products.reorder_quantity -> result; products.preferred_supplier_id -> purchase_orders; products.last_reorder_date -> result; supplier_products.supplier_id -> purchase_orders; supplier_products.product_id -> purchase_order_details; supplier_products.unit_price -> purchase_order_details; purchase_orders.supplier_id -> result; purchase_orders.order_date -> result; purchase_orders.status -> result; purchase_order_details.purchase_order_id -> result; purchase_order_details.product_id -> result; purchase_order_details.quantity -> result; purchase_order_details.unit_price -> result; inventory_logs.product_id -> result; inventory_logs.change_type -> result; inventory_logs.quantity_change -> result; inventory_logs.change_date -> result"
"WITH RECURSIVE date_range AS (SELECT CAST(DATE_TRUNC('month', CURRENT_DATE) AS DATE) AS date UNION ALL SELECT date + INTERVAL '1 day' FROM date_range WHERE date < LAST_DAY(CURRENT_DATE)), daily_sales AS (SELECT DATE(o.order_date) AS sale_date, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS daily_revenue FROM orders o JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date >= DATE_TRUNC('month', CURRENT_DATE) AND o.order_date <= CURRENT_DATE GROUP BY DATE(o.order_date)), product_sales AS (SELECT p.product_id, p.product_name, c.category_id, c.category_name, SUM(od.quantity) AS total_quantity, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_revenue FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id WHERE o.order_date >= DATE_TRUNC('month', CURRENT_DATE) AND o.order_date <= CURRENT_DATE GROUP BY p.product_id, p.product_name, c.category_id, c.category_name) SELECT dr.date, COALESCE(ds.daily_revenue, 0) AS daily_revenue, SUM(COALESCE(ds.daily_revenue, 0)) OVER (ORDER BY dr.date) AS cumulative_revenue, (SELECT JSON_OBJECT('top_product', (SELECT product_name FROM product_sales ORDER BY total_revenue DESC LIMIT 1), 'top_category', (SELECT category_name FROM product_sales GROUP BY category_id, category_name ORDER BY SUM(total_revenue) DESC LIMIT 1), 'total_products_sold', (SELECT SUM(total_quantity) FROM product_sales))) AS sales_summary FROM date_range dr LEFT JOIN daily_sales ds ON dr.date = ds.sale_date ORDER BY dr.date;","orders.order_id -> result; orders.order_date -> result; order_details.order_id -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result; order_details.product_id -> result; products.product_id -> result; products.product_name -> result; products.category_id -> result; categories.category_id -> result; categories.category_name -> result"
"CREATE FUNCTION calculate_customer_lifetime_value(customer_id INT) RETURNS DECIMAL(10,2) DETERMINISTIC BEGIN DECLARE total_revenue DECIMAL(10,2); DECLARE avg_order_value DECIMAL(10,2); DECLARE purchase_frequency DECIMAL(10,2); DECLARE customer_value DECIMAL(10,2); DECLARE customer_lifespan INT; DECLARE clv DECIMAL(10,2); SELECT SUM(total_amount) INTO total_revenue FROM orders WHERE customer_id = customer_id; SELECT AVG(total_amount) INTO avg_order_value FROM orders WHERE customer_id = customer_id; SELECT COUNT(*) / NULLIF(DATEDIFF(MAX(order_date), MIN(order_date)) / 365, 0) INTO purchase_frequency FROM orders WHERE customer_id = customer_id; SET customer_value = avg_order_value * purchase_frequency; SELECT DATEDIFF(COALESCE(MAX(order_date), CURDATE()), MIN(order_date)) / 365 INTO customer_lifespan FROM orders WHERE customer_id = customer_id; SET clv = customer_value * customer_lifespan; RETURN COALESCE(clv, 0); END;","orders.customer_id -> result; orders.total_amount -> result; orders.order_date -> result"
"WITH RECURSIVE category_hierarchy AS (SELECT category_id, parent_category_id, category_name, 0 AS level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.parent_category_id, c.category_name, ch.level + 1 FROM categories c JOIN category_hierarchy ch ON c.parent_category_id = ch.category_id), category_sales AS (SELECT c.category_id, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_sales FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN products p ON od.product_id = p.product_id JOIN categories c ON p.category_id = c.category_id WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY c.category_id) SELECT ch.category_id, ch.category_name, ch.level, COALESCE(cs.total_sales, 0) AS total_sales, COALESCE(parent_ch.category_name, 'Root') AS parent_category_name, COALESCE(parent_cs.total_sales, 0) AS parent_total_sales, CASE WHEN parent_cs.total_sales > 0 THEN (cs.total_sales / parent_cs.total_sales) * 100 ELSE 0 END AS percent_of_parent_sales FROM category_hierarchy ch LEFT JOIN category_sales cs ON ch.category_id = cs.category_id LEFT JOIN category_hierarchy parent_ch ON ch.parent_category_id = parent_ch.category_id LEFT JOIN category_sales parent_cs ON ch.parent_category_id = parent_cs.category_id ORDER BY ch.level, total_sales DESC;","categories.category_id -> result; categories.parent_category_id -> category_hierarchy; categories.category_name -> result; orders.order_id -> result; orders.order_date -> result; order_details.order_id -> result; order_details.product_id -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result; products.product_id -> result; products.category_id -> result"
"WITH RECURSIVE employee_hierarchy AS (SELECT employee_id, manager_id, first_name, last_name, salary, 1 AS level FROM employees WHERE manager_id IS NULL UNION ALL SELECT e.employee_id, e.manager_id, e.first_name, e.last_name, e.salary, eh.level + 1 FROM employees e JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id), department_stats AS (SELECT department_id, AVG(salary) AS avg_salary, COUNT(*) AS employee_count FROM employees GROUP BY department_id) SELECT eh.employee_id, eh.first_name, eh.last_name, eh.level, d.department_name, ds.avg_salary, ds.employee_count, eh.salary, (eh.salary - ds.avg_salary) AS salary_difference FROM employee_hierarchy eh JOIN employees e ON eh.employee_id = e.employee_id JOIN departments d ON e.department_id = d.department_id JOIN department_stats ds ON d.department_id = ds.department_id WHERE eh.level <= 3 ORDER BY eh.level, salary_difference DESC;","employees.employee_id -> result; employees.manager_id -> employee_hierarchy; employees.first_name -> result; employees.last_name -> result; employees.salary -> result; employees.department_id -> department_stats; departments.department_name -> result; departments.department_id -> result"
"WITH sales_summary AS (SELECT product_id, customer_id, SUM(quantity) AS total_quantity, SUM(quantity * unit_price * (1 - discount)) AS total_revenue FROM sales GROUP BY product_id, customer_id), customer_ranking AS (SELECT customer_id, SUM(total_revenue) AS customer_total_revenue, RANK() OVER (ORDER BY SUM(total_revenue) DESC) AS customer_rank FROM sales_summary GROUP BY customer_id), product_ranking AS (SELECT product_id, SUM(total_revenue) AS product_total_revenue, RANK() OVER (ORDER BY SUM(total_revenue) DESC) AS product_rank FROM sales_summary GROUP BY product_id) SELECT c.customer_id, c.company_name, cr.customer_total_revenue, cr.customer_rank, p.product_id, p.product_name, pr.product_total_revenue, pr.product_rank, ss.total_quantity, ss.total_revenue FROM sales_summary ss JOIN customers c ON ss.customer_id = c.customer_id JOIN products p ON ss.product_id = p.product_id JOIN customer_ranking cr ON ss.customer_id = cr.customer_id JOIN product_ranking pr ON ss.product_id = pr.product_id WHERE cr.customer_rank <= 10 AND pr.product_rank <= 20 ORDER BY cr.customer_rank, pr.product_rank;","sales.product_id -> sales_summary; sales.customer_id -> sales_summary; sales.quantity -> sales_summary; sales.unit_price -> sales_summary; sales.discount -> sales_summary; customers.customer_id -> result; customers.company_name -> result; products.product_id -> result; products.product_name -> result"
"INSERT INTO order_summary (order_id, customer_id, order_date, total_amount, status) SELECT o.order_id, o.customer_id, o.order_date, (SELECT SUM(quantity * unit_price * (1 - discount)) FROM order_details WHERE order_id = o.order_id) AS total_amount, CASE WHEN o.shipped_date IS NULL THEN 'Pending' WHEN o.shipped_date <= CURRENT_DATE THEN 'Shipped' ELSE 'Processing' END AS status FROM orders o WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH) AND NOT EXISTS (SELECT 1 FROM order_summary os WHERE os.order_id = o.order_id);","orders.order_id -> order_summary; orders.customer_id -> order_summary; orders.order_date -> order_summary; orders.shipped_date -> order_summary; order_details.quantity -> order_summary; order_details.unit_price -> order_summary; order_details.discount -> order_summary"
"UPDATE employee_performance ep SET performance_score = (SELECT AVG(rating) FROM (SELECT p.rating FROM projects p JOIN employee_projects ep ON p.project_id = ep.project_id WHERE ep.employee_id = ep.employee_id AND p.end_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) UNION ALL SELECT s.score FROM skills_assessment s WHERE s.employee_id = ep.employee_id AND s.assessment_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR)) AS ratings), last_updated = CURRENT_TIMESTAMP WHERE ep.employee_id IN (SELECT employee_id FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE division_id = (SELECT division_id FROM divisions WHERE division_name = 'Sales')));","projects.rating -> employee_performance; projects.project_id -> employee_performance; projects.end_date -> employee_performance; employee_projects.project_id -> employee_performance; employee_projects.employee_id -> employee_performance; skills_assessment.score -> employee_performance; skills_assessment.employee_id -> employee_performance; skills_assessment.assessment_date -> employee_performance; employees.employee_id -> employee_performance; employees.department_id -> employee_performance; departments.department_id -> employee_performance; departments.division_id -> employee_performance; divisions.division_id -> employee_performance; divisions.division_name -> employee_performance"
"CREATE TABLE product_recommendations AS WITH customer_purchases AS (SELECT customer_id, product_id, SUM(quantity) AS total_quantity FROM orders o JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY customer_id, product_id), product_pairs AS (SELECT cp1.customer_id, cp1.product_id AS product_1, cp2.product_id AS product_2, COUNT(*) AS pair_frequency FROM customer_purchases cp1 JOIN customer_purchases cp2 ON cp1.customer_id = cp2.customer_id AND cp1.product_id < cp2.product_id GROUP BY cp1.customer_id, cp1.product_id, cp2.product_id), product_similarity AS (SELECT product_1, product_2, pair_frequency, pair_frequency / (SELECT COUNT(DISTINCT customer_id) FROM customer_purchases WHERE product_id = product_pairs.product_1) AS similarity_score FROM product_pairs) SELECT ps.product_1 AS base_product_id, p1.product_name AS base_product_name, ps.product_2 AS recommended_product_id, p2.product_name AS recommended_product_name, ps.similarity_score, ROW_NUMBER() OVER (PARTITION BY ps.product_1 ORDER BY ps.similarity_score DESC) AS recommendation_rank FROM product_similarity ps JOIN products p1 ON ps.product_1 = p1.product_id JOIN products p2 ON ps.product_2 = p2.product_id WHERE ps.similarity_score >= 0.1 ORDER BY ps.product_1, ps.similarity_score DESC;","orders.customer_id -> product_recommendations; orders.order_id -> product_recommendations; orders.order_date -> product_recommendations; order_details.order_id -> product_recommendations; order_details.product_id -> product_recommendations; order_details.quantity -> product_recommendations; products.product_id -> product_recommendations; products.product_name -> product_recommendations"
"WITH RECURSIVE category_tree AS (SELECT category_id, parent_category_id, category_name, 0 AS level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.parent_category_id, c.category_name, ct.level + 1 FROM categories c JOIN category_tree ct ON c.parent_category_id = ct.category_id), category_products AS (SELECT c.category_id, COUNT(p.product_id) AS product_count FROM categories c LEFT JOIN products p ON c.category_id = p.category_id GROUP BY c.category_id), category_sales AS (SELECT p.category_id, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS total_sales FROM products p JOIN order_details od ON p.product_id = od.product_id JOIN orders o ON od.order_id = o.order_id WHERE o.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR) GROUP BY p.category_id) SELECT ct.category_id, ct.category_name, ct.level, COALESCE(cp.product_count, 0) AS product_count, COALESCE(cs.total_sales, 0) AS total_sales, (SELECT category_name FROM category_tree WHERE category_id = ct.parent_category_id) AS parent_category_name FROM category_tree ct LEFT JOIN category_products cp ON ct.category_id = cp.category_id LEFT JOIN category_sales cs ON ct.category_id = cs.category_id ORDER BY ct.level, ct.category_name;","categories.category_id -> result; categories.parent_category_id -> category_tree; categories.category_name -> result; products.product_id -> category_products; products.category_id -> category_products; order_details.quantity -> category_sales; order_details.unit_price -> category_sales; order_details.discount -> category_sales; order_details.product_id -> category_sales; orders.order_id -> category_sales; orders.order_date -> category_sales"
"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT AVG(salary) FROM salaries s2 WHERE s2.employee_id IN (SELECT e2.employee_id FROM employees e2 WHERE e2.department_id = e.department_id) AND s2.effective_date <= CURRENT_DATE AND (s2.end_date IS NULL OR s2.end_date > CURRENT_DATE)) AS avg_dept_salary, s.salary, (s.salary - (SELECT AVG(salary) FROM salaries s2 WHERE s2.employee_id IN (SELECT e2.employee_id FROM employees e2 WHERE e2.department_id = e.department_id) AND s2.effective_date <= CURRENT_DATE AND (s2.end_date IS NULL OR s2.end_date > CURRENT_DATE))) AS salary_difference, (SELECT COUNT(*) FROM performance_reviews pr WHERE pr.employee_id = e.employee_id AND pr.review_date >= DATE_SUB(CURRENT_DATE, INTERVAL 2 YEAR) AND pr.rating >= 4) AS high_performance_count, (SELECT AVG(rating) FROM performance_reviews pr WHERE pr.employee_id = e.employee_id AND pr.review_date >= DATE_SUB(CURRENT_DATE, INTERVAL 2 YEAR)) AS avg_performance_rating FROM employees e JOIN departments d ON e.department_id = d.department_id JOIN salaries s ON e.employee_id = s.employee_id WHERE e.hire_date > (SELECT DATE_SUB(MAX(hire_date), INTERVAL 5 YEAR) FROM employees) AND s.effective_date <= CURRENT_DATE AND (s.end_date IS NULL OR s.end_date > CURRENT_DATE) ORDER BY salary_difference DESC, avg_performance_rating DESC;","employees.employee_id -> result; employees.first_name -> result; employees.last_name -> result; employees.department_id -> result; employees.hire_date -> result; departments.department_name -> result; departments.department_id -> result; salaries.salary -> result; salaries.employee_id -> result; salaries.effective_date -> result; salaries.end_date -> result; performance_reviews.employee_id -> result; performance_reviews.review_date -> result; performance_reviews.rating -> result"
"WITH customer_orders AS (SELECT customer_id, COUNT(*) AS order_count, SUM(total_amount) AS total_spent, AVG(total_amount) AS avg_order_value, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id), customer_segments AS (SELECT customer_id, CASE WHEN order_count >= 10 AND total_spent >= 5000 THEN 'VIP' WHEN order_count >= 5 AND total_spent >= 2000 THEN 'Regular' WHEN order_count >= 2 AND total_spent >= 500 THEN 'Occasional' ELSE 'New' END AS segment, NTILE(5) OVER (ORDER BY total_spent DESC) AS spending_quintile FROM customer_orders), product_categories AS (SELECT p.product_id, c.category_name, pc.parent_category_id FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN categories c ON pc.category_id = c.category_id), customer_preferences AS (SELECT o.customer_id, pc.category_name, COUNT(*) AS purchase_count, SUM(od.quantity * od.unit_price * (1 - od.discount)) AS category_spent FROM orders o JOIN order_details od ON o.order_id = od.order_id JOIN product_categories pc ON od.product_id = pc.product_id GROUP BY o.customer_id, pc.category_name) SELECT c.customer_id, c.first_name, c.last_name, c.email, co.order_count, co.total_spent, co.avg_order_value, co.last_order_date, cs.segment, cs.spending_quintile, cp.category_name AS preferred_category, cp.purchase_count AS category_purchase_count, cp.category_spent FROM customers c JOIN customer_orders co ON c.customer_id = co.customer_id JOIN customer_segments cs ON c.customer_id = cs.customer_id LEFT JOIN (SELECT customer_id, category_name, purchase_count, category_spent, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY category_spent DESC) AS category_rank FROM customer_preferences) cp ON c.customer_id = cp.customer_id AND cp.category_rank = 1 ORDER BY cs.spending_quintile, co.total_spent DESC;","orders.customer_id -> result; orders.order_id -> result; orders.total_amount -> result; orders.order_date -> result; customers.customer_id -> result; customers.first_name -> result; customers.last_name -> result; customers.email -> result; products.product_id -> result; products.category_id -> result; product_categories.category_id -> result; product_categories.parent_category_id -> result; categories.category_id -> result; categories.category_name -> result; order_details.order_id -> result; order_details.product_id -> result; order_details.quantity -> result; order_details.unit_price -> result; order_details.discount -> result"
